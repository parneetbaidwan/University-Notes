# CS1026 - Lecture 1

## Intro to Programming

### Calculating
Operators:
- +, -, *, /, exponents and parentheses
- Variables are used to save values
- Mathematical operators can be used for variables and numbers (literals)

### Variables
Variables hold values and update over time
Rules for naming:
- Letters, numbers and underscores
- Cannot start with a number
- Use informative names

### Division
- Two types of Division: Division and Integer Division
- Division: Divide normally
    - eg) 12/5 = 2.4
- Integer Division: Decimal part is removed
    - eg) 12//5 = 2
- Related operation: mod (%): Gives you only the remainder numerical
    - eg) 12%5 = 2 --> (5+5+2 = 12)

### Statements and Expressions
- Expression: any combination of literals, variables, and operations
- Statement: a line of code that can be executed
- Assignment Statement: "Variable = Expression"
    - "assign the variable the value of the expression"
    - **Only a variable** on the left hand side
    - Equal sign is the assignment operator

### Saving Code
- Save as a .py file
- Executes all at once

### Algorithms
- Once we start saving code, we are implementing algorithms
- Algorithm: A sequence of steps that accomplish a specific task
    - Finite set of steps, depends on data that we get
    - Always solves the problem
- They aren't specific to a language like Python
- When solving problems, algorthms are written before the code is written

### Operations
- Function calls: trig functions, square root, floor, ceiling, logs
- Math module:
    - Import math
    - To use a function, give name and the information needed
    - Store the result in a variable or use an expression
- Math Operators:
    - math.sin, math.tan, math.cos, math.asin...(radians)
    - math.degrees, math.radians (to convert)
    - math.sqrt
    - math.exp, math.log, math.log10
    - math.pi
- Non-math Operators
    - abs() - calculate the absolute value of a numerical value
    - round() - round a numerical value (to a certain number of decimal points)
- String Operations
    - '+' - concatenation (adding strings together)
    - '*' repition
    - len(x) - gives length of string

### Strings
- Store zero or more characters
- Can be assigned to variables and used in expressions
- Define using single or double quotes(' ', " ")
    - eg) myStr = 'COMPSCI 1026B'

### Types
- Strings and numeric values (ints, floats) are different types
- One variable can hold different types over its lifetime
- Some operations only work for some types

### Extracting information from strings
- Can extract a character from a string
- Use square brackets after the string name and provide position
- Position begins at zero, not one

### String Tools
- myStr.upper() - uppercase version of myStr
- myStr.lower() - lowercase version of myStr
- myStr.replace(oldText, newText) -  create a new version with the replacements

### Special Characters
- \n - newline character
- \t - tab character
- \'' or \' - quote characters
- \\ - backslash character

### User Input
- input()
    - Function returns the input the user types
    - Can specify a prompt (string) as a parameter to the function
    - Typically, store user input in a variable
        - use float() to convert to float
        - use int() to convert to integer
        
### Formatting
- Basic method:
    - `print('I want to show you', var1, 'and', var2)`
- Formatted:
    - `print('I want to show you {} and {}'.format(var1, var2))`
    - {} is where the variable will go
- Can also format decimals
    - {:.2f} will result in 2 decimal places
    - `print('A number: {:.2f}'.format(floatingVar))

### Comments
- Anything written after '#' is a comment
- Ignored within the actual code
- Can also use ''' ''' for long paragraphs of comments


### circleArea.py
this program computes the area of a circle from its radius
```
userInp = input('Please type in the circle radius: ')
radius = float(userInp)
area = 3.141 * (radius**2) # area formula
print('The area of a circle with the radius {} is {:.2f).'.format(radius,area))
```
- output assuming radius is 2: 12.56

### firstCode.py
```
radius = 5
area = 3.141 * (radius**2)
print(area)
print(radius)

radius = 10
area = 3.141 * (radius**2)
print(area)
```
- output: 
    - 78.525
    - 5
    - 314.1
    
### firstInput.py
```
userInp = input('Type in your first name: ')
greeting = 'Hi' + userInp
print(greeting)
```
- output: Hi Parneet

### mathOps.py
```
import math
a = 1
b = 6
c = 3

x = (-b + math.sqrt(b**2 - 4*a*c)) / 2*a
print(x)
```
- output: -0.5505102572168221

### string.py
``` 
myString = 'this is some text'
secondString = 'more text'
print(myString + secondString)

newString = myString * 3
print(newString)

print(len(myString))
firstCharacter = myString[0]
print(firstCharacter)
```
- output:
    - this is some textmore text
    - this is some textthis is some textthis is some text
    - 17
    - t


# CS1026 - Lecture 2

## Conditions

### Conditions
- Conditions are a way to represent whether something is true or false
  - 3 > 5 
  - x >= 5

### Relational Operators
- Operators are needed to express conditions
- Comparisons between two values:
  - >, >=, <, <=
- Equality and non equality:
  - ==, !=

### If Statements
```
if(condition):
  #statement1
  #statement2
```
- Statements will only execute if the condition is true
- White space is very important --> Lines must be indented

### If with Else
```
if(condition):
  # executed if condition is TRUE
else:
  # executed if condition is FAlSE
```

### If, Elif, Else
```
if(condition1):
  # executes if condition1 is true
elif(condition2):
  # executes if condition2 is true
else:
  # executes if neither condition is true
```

### Boolean Operators
- and: true if both conditions are true
  - eg) x >= 0 and x <= 10
- or: true if one or both conditions are true
  - eg) grade < 0 or grade > 100
- not: "flip" the true - true if condition is false and vice versa
  - eg) not(x > 0)
  
- Short Circuit Evaluations
  - Evaluate the left operand and only evaluate the right if needed
    - or: if the left is true, expression is true
    - and: if left is false, expression is false
    
### Comparisons
- Comparing Floating Point Numbers
  - avoid using equality with floating point numbers:
    - 67.76 * 100
  - use epsilon - a small floating point tolerance that represents "close enough"
    - test |x - y| < epsilon for some small value of epsilon
      ```
      epsilon = 1e - 14
      if(abs(x-y) < epsilon):
      ```
- Comparing Strings
  - compare with == and !=
    - every single character in both strings are the same:
      - same length
      - each position is the same character
      
  - compare with < 
    - operator is true for two strings if they are in lexicographic order
      - "alphabetical order", "phone book order"
    - easy if two strings differ in some position
    - if one string is a prefix of the other, it comes first:
      - eg) David < Davidson
    - Numbers --> Uppercase --> Lowercase

### Boolean Values
- True and False
  - Store values in a variable:
    - `boolVar = True`
  - Can be the result of a comparison:
    - `boolVar = (1 > 3)`
  - Can use in if statements
    - ```
      boolVar = (1 > 3)
      if boolVar:
        print('...')
       ```
### Try-Except
- A condition Statement but without explicit conditions
- Used primarily for error handling
- ```
  userInput = input('Enter an integer: ')
  try:
    integerValue = int(userInput)
  except ValueError:
    print('Error, etc...')
  ```

### boolOps.py
```
grade = 50
if grade < 0 or grade > 100:
  print('grade is invalid')
else:
  print('grade is valid')
```

### elifExample.py
```
x = 10
y = 5
z = 30

if x == y:
  print('x and y are the same')
elif x > z:
  print('x is greater than z')
elif y > z:
  print('y is greater than z')
else:
  print('nothing above was true')

print('goodbye :)')
```

### firstIf.py
```
# short program showing how to use an if statement

# get user input
userInp = input('Enter your revenue: ')
revenue = float(userInp)

userInp = input('Enter your expenses: ')
expenses = float(userInp)

# your net
net = revenue - expenses

if net >= 0:
  print('You made a profit of ${}'.format(net))
  print('Good job!')
else:
  print('You lost ${}'.format(net))
  print('Better luck next time.')
print('Goodbye.')
```

# CS1026 - Lecture 3

## Iteration

### While Loops
- While Loop: Test a condition and execute the code if the condition is true, repeat
```
while(condition):
    #body
```

### Example Loop
```
counter = 0  # before loop
while(counter < 5):
    print('count is {}'.format(counter))
    counter = counter + 1
print('done loop')  # after loop
```

### While Loop Test
- While loop condition is tested:
    - when the loop is first encountered
    - after each execution of the body of the loop
- When designing your loop, make sure it captures what you want each time

### Infinite Loops
```
counter = 0
while (counter < 10):
    print('counter is {}'.format(counter))
```

- Missing an incrementation

### Other While Loop Pitfalls
- Floating point loops:
    - avoid use of floats, instead use integers
- Continue to update everytime

### Input Processing Loops
1. Verifying that a user inputs a correct value
2. Allowing multiple input

### Verifying Input
- Prompt the user for input
- While test should be - "while input is **no good**
- Inside loop: kindly remind user with prompt

### Allowing Multiple Loop
```
num = int(input('Enter a number(-1 to quit): ')
while(num != -1):
    # process num
    # prompt again
```
- Sentinel Value:
    - Special value that signals the end of input
    - Sentinel should not be a valid input value
 
### Flag Variables
- Can use a variable that stores a Boolean value as a **flag variable**
- The variable flags that the loop should end
- Useful for complex loops
```
boolVar = True
boolVar = (x > 0)
```

```
done = False  # done is the flag var
while (not done):
    # processing
    if (condition):
        done = True
    else:
        # more processing
```

### For Loop
- For loops are another form of a loop that work a predefined number of times
```
for i in range(5):
    print('the value of i is {}'.format(i))
```

### for loop or while loop
- for loop: 
    - if you know how many times the loop will execute
- while loop: 
    - if the condition relies on unknown information
    - if you can express a Boolean condition
 
### range()
- range(a,b,c)
    - a: starting value
    - b: end before this value (at b-1)
    - c: skip by this value
- examples:
    - range(4,20) --> 4, 5, 6, 7,...17, 18, 19
    - range(-5,10,3) --> -5, -2, 1, 4, 7

### For Loop over Strings
- Can use a for loop with range() for strings, but can also work with characters
```
for char in myStr:
    print(char)
```

### Nested Loops
- When loops are within loops: **Inner loop executes first**

```
for i in range(5):
    for j in range(4):
        print("{},{}".format(i,j))
```

output: 
- 0,0
- 0,1
- ...
- 1,0

### circleArea2.py
```
# this program computes the area of the circle from its radius

userInp = input('Please type in the circle radius (positive): ')
radius = float(userInp)

while radius < 0:
    # know that the input is bad
    userInp = input('Your input of {} was negative. Please enter a positive: '.format(radius))
    radius = float(userInp)

area = 3.141 * (radius**2)
print('The area of a circle with the radius {} is {:.2f}.'.format(radius,area))
```

output:
- input: -3
    - "Your input of -3 was negative. Please enter a positive: "
- input: 1
    - 3.141
    
### firstWhile.py
```
counter = 1

print('Before while loop')

while (counter <= 5):
    print('Counter is {}'.format(counter))
    counter += 1
    
print('After while loop')
```
output:
- Before while loop
- Counter is 1
- Counter is 2
- Counter is 3
- Counter is 4
- Counter is 5
- After while loop

### forLoops.py
```
# simple range statement
for i in range(10):
    print('The value of i is {}.'.format(i))
    if i <= 3:
        print('small')
    else:
        print('large')
        
# even numbers here
for i in range(2,10,2):
    print('The value of i is {}.'.format(i))
    if i <= 3:
        print('small')
    else:
        print('large')

myStr = 'abcdef'

for char in myStr:
    print(char)    
```

output:
    - The value of i is 0.
    - small
    - The value of i is 1.
    - small
    - ...
    - The value of i is 9.
    - large

    - The value of i is 2.
    - small
    - The value of i is 8.
    - large

    - a
    - b
    - f
    
### nested.py
```
for i in range(5):
    print('starting i loop')
    for j in range(4):
        print('{},{}'.format(i,j))

print('done')
```

- output:
    - starting i loop
    - 0,0
    - ...
    - 0,3
    - starting i loop
    - 1,0
    - ...
    - 1,3
    - starting i loop
    - 2,0
    - ...
    - 2,3
    - starting i loop
    - 3,0
    - ...
    - 3,3
    - starting i loop
    - 4,0
    - ...
    - 4,3
    - done
    

# CS1026 - Lecture 4

## Randomness and Simulation

### Random Numbers
- Useful for:
    - Games: introduce an element of randomness for user
    - Simulations: many complex problems can be solves approximately using randomness

### Generating Random Numbers
- Use random library
- random() function:
    - generates a number between 0 and 1: (0 <= r <= 1)
    - need to import
```
from random import random  # 1st - module; 2nd - function
r = random()
```

### "Random"
- The numbers aren't actually random: **pseudorandom**
- They are generated deterministically: repeat pattern length 2^19937 - 1
- Python documentation: "not suitable for cyrptographic purposes

### Pseudorandom and Seed
- Pseudorandom starts with a seed
- If the random generator gets the same seed, it generates the same results
- By default, the seed is based on the current time
- Setting the same seed value can be helpful to help debug your code: `random.seed(10)`

### Random Integers
```
from random import randint
r = randint(a,b)
```
Generates a random number between and including a and b

### Dice.py
```
from random import randint  # importing a random integer

count12 = 0  # how many times is 12 seen
count7 = 0  # how many times is 7 seen

for i in range(1000):  # 1000 dice rolls
    dice1 = randint(1,6)
    dice2 = randint(1,6)
    
    sumDice = dice1 + dice2
    
    if (sumDice == 12):
        count12 += 1
    elif (sumDice == 7):
        count7 += 1
        
print('We got {} 12s and {} 7s'.format(count12, count7))
```

Example Output: We got 32 12s and 171 7s


# CS1026 - Lecture 5

## Data Structures

### Variables
- Variables store a single value
    - Different types
    - Only one value at a time
- Data Structure: A way to store multiple values in a uniform way

### List
- A list stores multiple values at once
- Lists are:
    - Heterogenous: Can store different types at the same time
    - Dynamic: The number of values in a list can change over time
    - Ordered: We can access elements form the list by asking for the position data

- Lists are defined using square brackets and a name:
    - `mylist = [2, -1, 5]

- To access one value, use square brackets after the variable name:
    - `mylist[0]`
    - this would result in: 2

### Indexing
- Indexing: accessing a value using []
    - Used to read or write a list value

- len() for length of list
- Index: the value inside the brackets; position you are accessing
    - always starts at 0

- Indexing out of list length will give an error
- Last element:
    - `mylist[len(mylist) - 1]`
    - `mylist[-1]`

### Creating Lists
- List with elements:
    - define variable and add elements with square brackets
    - `myList = [e1, e2, e3]

- List with no elements:
    - define variable and add square brackets with nothing between them
    - `myList = []`

- Another way:
    - `myList = list()`

### Slicing
- Slicing: extract regions of a list 
    
- `myList[a:b]`
    - Starts at a; ends at value before b (b-1)
    - If a or b is omitted, python will use the start or end of the list respectively
    - Result: new list
        - However, when you index with a single integer, you will get an integer

- `myList[a:b:c]`
    - Starts at a; ends at value before b; skips by value of c
    - Any number can be negative

### List Operations
- Concatenation: adding two lists using '+'
- Repetition: repeat a list using '*'
    - `myList = [0] * 10`

- list1.append(x): add element x to the end of list1
- list1.extend(list2): add all of list2 to the end of list1
    - .extend() modifies the list and creates a new list
    
- list1.insert(k,x): insert element x at the spot k in list1
    - everything at spot k and up is shifted up by one
    - if k is bigger than the length, the element is added at the end

- list.pop(k): remove element at the spot k in list1
    - everything at spot k and beyond is shifted down
    - everything that is removed is returned by the call
    - if k is bigger than the length, error
    - if k is not provided, remove the last element

- list.remove(x): remove the first occurence of element x from list1
    - smallest index
    - everything past the deleted is shifted down one spot
    - if the element isn't in the list, an error will occur
    - Pop vs. Remove:
        - removing an element, not a position

### List Tests
- in
    - tests whether an element is in the list:
        - `if x in list1:`

- not in
    - tests whether an element is not in the list:
        - `if x not in list1`

- index()
    - finds the index of an element
        - returns an error if the element isn't in the list

    - `list.index(x)`

### Equality
- Use == and != 
- Tests whether each element at every position is equal

### References (Pointers)
- List variables use references
- The reference is the address (in memory) of where the list data is stored
- The list variable contains the reference

### List Assignment
- What happens when -> `list1 = list2`
    - Copying the refernce in list2 into the list1 variable
    - NOT COPYING THE DATA
    - Effect:
        - list1 is now an alias for list2
        - changes to list 1 affect list2 and vice versa

- To get a separate copy:
    - Use slicing:
        - `list1 = list2[:]

    - Use list keyword:
        - `list1 = list(list2)

### Numerical List Operations
- sum(L): add all the elements of a list
- max(L): find the biggest element
- min(L): find the smallest element
- sorted(L): return a sorted version of the list
- L.sort(L): sort the list "in place" --> no new list

### String List Operations
- Can use max, min, sorted, and sort
- Instead of sum, use join
    - x.join(list)
        - x is element that is glued between the list elements
        - `' '.join(list)` --> Common

### Tuples
- Similar to lists but immutable; cannot change the content
- Use round brackets to define
    - `myTuple = (1, 3, 5, 7, 8)
- Can also be indexed
    - `myTuple[1]`

### Tuple Operations
- len, in, ==

### Simultaneous Assignment
- Suppose x and y are already variables
- Use tuples to swap values
    - `(x,y) = (y,x)`
- Can be done for any number of variables

### Strings as Data Structures
- Strings are immutable
    - No aliasing problem
    - No writing to individual characters using []

### For Loops and Data Structures
- For loops can be used to iterate over data structures
```
myList = [1, 2, 3]
for x in myList:
    print(x)

output:
1
2
3
```

### For loops with range
- Range can also be used with data structures:
```
for posn in range(len(myList)):
    # use posn as an index in the list
    # eg. myList[posn]
    print(myList[posn])
```

### Multi-dimensional Lists
- Can have multi-dimensional lists
- `table = [[1,2,3], [4,5,6], [7,8,9]]`
- Can be indexed:
    -`table[0][1]` is equal to 2 (first list, second item)
    
- Accessing:
    - Using in:
        ```
        for row in table:
            for elem in row:
                # can access element
        ```
    - Using ranges:
        ```
        for i in range(len(table)):  # number of rows
            for j in range(len(table[i])):  # number of columns
                # can access table[i][j]
        ```
                
     - For bigger sizes:
        - Use '*' to create bigger arrays
        ```
        table = []
        for i in range(numRows):
            table.append([0] * numCols)
        ```

### Ragged Multidimensional Arrays
- Lengths of each row could differ (different number of columns)
- Both of the loop formats would still work
`ragged = [[1], [2,3], [4,5,6], [7]]`
       

### firstList.py
```
TWO = 1
myList = ['mike', 2, 3.141, 99]  # defining a list of length 4

print('First element in the list is {}'.format(myList[0]))

myList[TWO] = 9000.1  # updates a position in the list

print(myList)
print(len(myList))
```
- output: 
    - First element in the list is mike
    - mike, 9000.1, 3.141, 99
    - 4
### list2d.py
```
myTable = [ [1,2,3,4], [5,6,7,8], [9,10,11,12]]
# 1  2  3  4
# 5  6  7  8
# 9 10 11 12

# print(myTable[1][3])

for i in range(len(myTable)):  # i = 0, 1, 2
    print(myTable[i]) # print whole row
    for j in range(len(myTable[i])):  # j = 0, 1, 2, 3
        print(myTable[i][j])
        print('--')
    print('done row {}'.format(i))
```

- output:
    - ```
     [1,2,3,4]
     1
     --
     2
     --
     3
     --
     4
     done row 0
     ...
    
    - ```
### listAsst.py
```
list1 = ['alpha', 'beta', 'gamma', 'delta', 'epsilon']
list2 = list1

print('list2 is {}'.format(list2))

list2.append('omega')  # changing list 2

print('list1 is {}'.format(list1))  # change is seen in list 1 also
```
- output:
    - ```
    list 2 is ['alpha', 'beta', 'gamma', 'delta', 'epsilon']
    list 1 is ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'omega']
    ```

### listTests.py
```
# create a list
list1 = ['alpha', 'beta', 'gamma', 'delta', 'epsilon']

# use 'in' test

if 'omega' in list1:
    print('yes')
    posn = list1.index('omega')  # if it exists, this is the position
else:
    print('no')

list2 = ['beta', 'alpha', 'gamma', 'delta', 'epsilon']

# print(list1 == list2) --> False
list3 = list2
```
- output: no

# CS1026 - Lecture 6 

## Functions

### Organizing Code
- You can write code that becomes more and more complex but that creates problems
- Problems of **maintainability**:
    - Code becomes harder to read, write, modify, and debug
    - Hence, need to improve organization of the code

- Maintainance:
    - involves reading existing code
    - if the code is not readable and organized, it is going to be hard to maintain

### Functions
- Isolate **blocks of code** that form a self-contained task
- These tasks will be put in a **function**:
    - math functions: sin(), round(), sqrt()
    - abs()
    - print()
    - len()
- Functions:
    - can be called to produce effects or results
    - take information needed to do the job
        - len() takes a list, tuple, string
        - random() doesn't take any information

    - can return a piece of information
        - len() returns the length of the string or list
        - print() doesn't return anything

### Writing Functions
- Required information:
    - function name
    - information required to accomplish a task
    - provide code to do that task
    - return if applicable

### Simple Python Function
- ```
    def myFunction():
        # code
- ```
- First line is called the header - gives name, and other information
- Code is called the body
- Indentation, colon

### Writing a Function
- ```
    def myFunction(param1, param2):
        # body
        # typically use param1, param2
        
        return returnVariable
- ```

- **Parameters**:
    - Define the parameters in the header but do not assign them a value
    - Modifying Parameters:
        - What happens depends on the type of parameter
        - If that parameter is immutable (string, int, tuple...):
            - changes inside the function don't matter
            - changes do not affect the value when the function is done
        - If the parameter is mutable:
            - changes to a list in a function will create a permanent change

- **Body**:
    - **local variables**: variables defined in the body of the function
        - can't be accessed outside the function
        - created when function starts and destroyed when the function ends
        - could have two different local variables with same name in different functions

    - **global variable**: variables defined in a method and exist for the life of the method
        - defined outside a function that is visible inside a function defined
        - need to tell a function you want to access a global variable within the body
            - `global myVar` --> don't do this
            - instead: structure your code so info is passed by parameters 

- **Return**:
    - Last executed statement in the function
    - No code after the return statement
    - Try to only have one return statement per function
    - Can return a variable, value, expression, or a tuple

- main()
    - write this after your function
    - it should contain all the executable code in your program that's not in a function

### Calling a Function
- If you've written a function called myFunction, you can call it in your code:
    - `myFunction()`
- After defining your function, can call it by:
    - supplying the parameters (if any_
    - saving the result (if any)
    - ` myVar = myFunction(otherVar1, otherVar2)`

### Documenting Functions
- Use triple quotes (docstring) after the header to start a comment describing the function
- ```
    def iCry(Parneet):
        ''' this function cries a lot'''
        # body
- ```
- Include:
    - what the function does
    - what it returns
    - what the parameters are

### firstFunction.py
```
def myFunction():
    print('Hello World')
    print('More printing')
    
def myFunction2(myParam):
    print('You sent in the value {}'.format(myParam))
    return 2*myParam

def addTwoNumbers(param1, param2):
    '''
        addTwoNumbers: function that takes two parameters and returns their sum
        Parameters: param1 - a number
                    param2 - a number
        Returns: the sum of param1 and param2
    '''
    
    total = param1 + param2
    return total

def main():
    print('before function')
    myFunction()
    
    print('after function')
    
    myVar = 200
    x = myFunction2(myVar)  # call the function and send it parameter valued at 200
    
    print('We got back {}'.format(x))
    

main()
```
- output:
    - ```
        before function
        Hello World
        More Printing
        after function
        You sent in the value 200
        We got back 400 
    
    
### modifyParam.py
```
def function1(param1):
    # param is an integer
    param1 = 5
    print('in function: {}'.format(param1))
    
def function2(param1):
    # param is a list
    param1[0] = -1
    print('in function: {}'.format(param1))
    
def main():
    var = 10
    function1(var)
    print('after function, in main: {}'.format(var))
    
    print('--'*50)
    myList = [1,2,3]
    function2(myList)
    print('after function, in main: {}'.format(myList))


main()
```
- output:
    - ```
        in function: 5
        after function, in main: 10
        --------------------------------------------------
        in function: [-1,2,3]
        after function, in main: [-1,2,3]
    

# CS1026 - Lecture 7

## Files

### Files
- Python is able to easily open and read files
- Common types:
    - .txt files - plain text
    - .html files - includes HTML tags
    - .py files - plain text code
    - .csv files - can treat as plain text

- Often put the files in the same directory as the code

### open() command
- To open a file, specify the file name and what to do
    - `open('filename.txt','r')`
        - 'r' - read

- Other ways:
    - Assign to a variable:
        - `fileHandle = open('filename.txt', 'r')`
    - Use the with command to handle errors:
        - ```
            with open('filename.txt', 'r') as file_handle:
                # use file_handle to read the file
          ```
### filename.txt
- filename.txt is a string that gives the filename with extension
- file should be in the same directory as the cde
- if you want to give a longer path name, you can
- depends on the operating system:
    - windows: 'C:/Users/username/etc/file.txt'

### fileHandle
- fileHandle is the variable name
- the variable is a file object
- used to access the contents of the file

### File doesn't Exist
- FileNotFoundError
- to test:
    - import os
    - os.path.file('filename.txt') # returns a boolean

### Read file Contents
- `for lineVar in fileHandle:`
- lineVar is always a string
    - conversions (int(), float())
- Each time through the loop, lineVar contains the next line of the file
- Always contains the new line at the end of the line

### readline()
- Used to read one individual line
- `firstline = fileHandle.readline()`
- Can be useful:
    - if you need to read the first line and then decide what to do with the rest
    - if you need to read a fixed number of lines (using a for loop)

### read()
- Can read an individual character
- `c = fileHandle.read(1)  # read 1 char`
- If there's no more characters to read in the file, returns ' '(string of length 0)
- With a loop, test (c != ' ') to see if the end of the file has been reached

### Other ways to use file variables
- Can read all the lines at once:
    - listOfLines = fileHandle.readlines()
    - Careful about the size of the file!
- Can close the file:
    - fileHandle.close()
    - Can't access contents after close()
    - MUST DO if you are NOT using 'with'

### What happens when you read
- The file handle keeps track of "where you are" in the file
    - initially, you are at the start
    - Commands like readline() move you ahead
    - Always keep track

### What happens after you read
- After you read (eg: using `for line in fileHandle:`) you can't iterate over it again
    - Same command doesn't work
- Solutions?
    - Save contents(readlines())?
    - Reopen file?
    - Use fileHandle.seek(0)?

### Open files for writing
- `open('new_file.txt','w')`
- Do both input and output in one 'with' statement:
    - ```
        with open('file.txt','r') as infile, open('output.txt','w') as outfile:
            # use infile for input, outfile for output file
      ```
### Writing to a File
- If the file doesn't exist, it is created
- If the file exists, it is overwritten
- To add to a file instead of overwriting, use 'a' mode (append)
    - This will still create a new file if necessary

### Write Commands
- Instead of print, use write with file handle
- `outfile.write(contents + '\n')`
- Write newline ('\n') to your files
- IF YOU DON'T USE WITH, YOU MUST CLOSE THE FILE    

### String Processing
- Often need to process the strings that come from files:
    - Remove whitespace and newlines from the string
    - Process the information in a line of a file
- To do this, use string processing commands:
    - strip(), rstrip(), lstring() - remove whitespace
    - split() - split a string into parts

### Strip() Commands
- Strip is used to remove any whitespace - spaces, tabs, newline characters etc,
    - eg) "  mike  '\n' "  --> "mike"
- .rstrip() - removes all whitespace from the right side of the string
- .lstrip() - removes all whitespace from the left side of the string
- .strip() - removes all whitespace from both ends
- You can also strip characters:
    - `str.split(stripChars)`
    - Strips all characters in stripChars from the ends of str

### Split Command
- Steps:
    - String with a bunch of words:
        - `s = "CS 1026 Computer Science Fundamentals 1"`
    - Split breaks the string by whitespace, creates a **list**
        - `listWords = s.split`
    - List of "words" - parts of the string that are separated by spaces
        - `['CS', '1026', 'Computer', 'Science', 'Fundamentals', '1']
    - Removes all whitespace 

### Nested Loop for reading words
- To read a whole file word by word, use a nested loop
    - ```
        for line in fileHandle:
            words = line.strip().split:
            for word in words:
                # process words
      ```
      
### Split on Other Characters
- Can split on other characters
- x.split(char) splits the string whenever char appears
- Makes the most sense when char is a single character
- Remember: won't split on whitespace anymore
- `x.split(',')` - used for reading CSV files

### Reading from the web
- `from urllib.request import urlopen`
- use urlopen like open for files
- use URL instead of filename
- if the file is HTML, then you get all the tags in the file
- MAy need to decode the file ('UTF-8')
- Can be helpful for data sources on the internet

### firstFiles.py
```
with open('prov.txt', 'r') as fileHandle:
    firstLine = fileHandle.readline()
    print('First line: {}'.format(firstLine))
    
    for lineVar in fileHandle:
        print("@@{}@@".format(lineVar))
```
- output:
    - First line: Alberta

    - @@British Columbia
    - @@
    - @@Manitoba
    - @@
    - ...

### earthquakes.py
```
from urllib.request import urlopen

url = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv'

with urlopen(url) as u:
    for line in u:
        line = line.decode('UTF-8').strip().split(',')
        print(line)
```
- output:
    - `['time', 'latitude', 'longitude', 'depth', 'mag', 'magType', 'nst', 'gap', ...]`
    - Basically, it takes the excel file and turns each row into its own list
    
### movies.py
```
with open('HighestGrossers.txt'.'r') as fh:
    header = fh.readline()
    
    highest = 0
    best = ' '
    
    for line in fh:
        data = line.strip().split(',')
        # for x in data:
            # print x
        sales = int(data[6])  # ticket sales
        if sales > highest:
            highest = sales
            best = data[1]  # title
    print('Highest grossing movie of all time is {}, with sales of {}'.format(best,highest))
```
- output: 
    - this code opens the file, then reads the first line as the header (table header)
    - then each line after the header is stripped and split and added into list data
    - based on the header, the total sales is the 6th index
    - if sales is larger than the highest then the highest is equal to sales
    - the code then iterates over the entire file to find the highest and its title
    - `Highest grossing movie of all time is Titanic, with sales of 865842808`
### write.py
```
with open('prov.txt', 'r') as inp, open('output.txt', 'w') as out:
    out.write('this is data that we are writing\n')
    out.write('more data\n')
    for line in inp:   # reads line by line
        out.write('>' + line)
        words = line.strip().split()
        print(words)
        for w in words:   # inner loop goes over the words
            out.write(w + '\n')
```
- output: here a new file is created and there is an output
    - output: Each province name becomes a list split by word
        - ['Alberta']
        - ...
        - ['Newfoundland', 'and', 'Labrador']
        - ...
        - ['Yukon']
    - new file (output.txt): this file is created within the code:
        - this is data that we are writing
        - more data
        - >Alberta
        - Alberta
        - ...
        - >Ontario
        - Ontario
        - ...
        - >Yukon
        - Yukon


# CS1026 - Lecture 8

## Data Structures II

### Sets
- Sets are an unordered data structure
- Put data into a set but DO NOT CARE about the order of the data
- Useful and Efficient:
    - "is this element in the collection?"
    - faster to determine membership than lists

### Defining a Set
- Use {braces} to define a set
    - `S = {31, 41, 59, 42}`
- NO DUPLICATES
- Sets are unorders, can contain different types
- An empty set can be created using set():
    - `S = set()`
- Can convert a list to a set using set()
    - `mySet = set(myList)`

### Set Operations
- len(), in, ==, !=
- union: |
- intersection: &
- difference: -
- subset: <, <=

### Set Modifications
- add()
- remove()
- discard()

### Non-Set Operations
- Can't index a set
- Can't append to a set, pop(), insert()
- Can sort a set, but the result is not a set

### Accessing Elements
- If you can't index, how to access:
    - Use a for loop (like lists):
        - ```
            for elem in set:
                # can access elem now
           ```
           
### Dictionaries
- Data structures that associates two pieces of data together
- Association between a **key** and a **value**
- Use the key to **look up** the associated value
- Useful for looking up unique information:
    - Dictionaries (language)
    - Phonebooks

- Example: Define a dictionaries using braces but giving both keys and values:
- ```   
    pops = { 'China':1411778724, 'India':1384933962, 'USA':332790963, 'Pakistan':225200000 }
  ```

### Indexing a Dictionary
- To look up a value, use the key
    - `pops['China']`
- **KeyError** if you try and look up a key that doesn't exist

### Rules for Keys
- keys must be unique - each key is associated with a single value
- keys must be immutable:
    - strings, ints, tuples
    - NOT lists
- value can be anything - list, string, tuble, string, list of list...

### List vs. Dictionaries
- list: each item in the list is associated with a position (the index, an integer)
    - Lookup: i -> item in the list at position i
- dictionary: each value is associated with a key (doesn't have to be an integer)
    - Lookup: key -> value assocated with the key

### Dictionary Operations
- len(), in, ==
    - in: tells you if key is in dictionary
        - `if key in dict:    # can lookup dict[key]`
    - ==: tells you if key-value pairs are equal
- list(d): gives a list of keys of d
- Add or update key-value pair: d[key] = value
- Delete key-value pair: del d[key]

### Looping in Sets and Dictionaries
- Can loop over sets like lists
- Can loop over different things in a dictionary
    - `for k in d.keys():`
    - `for (k,v) in d.items():`
    - `for v in d.values():`

### Assignment Statements
- Same rules as list for assignment statements
    - s = t is just an alias
- To make a copy, use dict/set keywords:
    - d1 = dict(d2)


### dice_dict.py
```
from random import randint  # random integer

count = {}

for i in range(1000)  # execute 1000 dice rolls
    dice1 = randint(1,6)
    dice2 = randint(1,6)
    sumDice = dice1 + dice2
    
    if sumDice in count:
        count[sumDice] += 1
    else:
        count[sumDice] = 1
 
 for k in sorter(count.keys()):
    print('The number of times we rolled {} is {}'.format(k, count[k]))
```
- output:
    - The number of times we rolled 2 is 17
    - ...
    - The number of times we rolled 12 is 36


# CS1026 - Lecture 9

## Exceptions

### Exceptions
- Handline input - what happens if we try to execute the following:
    - ```
        str = 'three'
        intVal = int(str)
      ```
    - The code will crash
    - **Exceptions** handle the errors and allow the code to recover

### Causes of Exceptions
- Errors can happen anywhere
    - ValueError: using int(), float()
    - FileNotFoundError: other file errors
    - ZeroDivisionError: divide by zero
    - IndexError: x[n] for n > len(x) - index not found
    - NameError: variable doesn't exist
    - TypeError: incorrect type

### Handling Exceptions
- Try-except block:
    - ```
        try:
            # code you want to try
        except EXCEPTION-NAME:
            # code that helps recover
      ```
    - Code starts executing at the start of the try block
    - If no error occurs, whole try block will execute
    - If error occurs in the try block, code stops and except block that matches error is found
        - Can have multiple except blocks

    - If except block is found, except block is executed
        - the except block might:
            - ask user to try and fix the error
            - end the program gracefully
    - Code continues after the end of the try-except block

### Multiple except blocks
```
try:
    # code that may cause errors
except Error1:
    # block 1
except Error2:
    # block 2
except Error3:
    # block 3
```

### Getting more information from the exception
- An exception can give you an error message - convert to string
    - `str(exception)`
- Can give a name to the exception in the try-except block
    - `except ValueError as ve:    # use ve as a variable`

### Unknown Error
- Can create an except block with general exception
- `except Exception:    # handle all exceptions`
- Dangers:
    - don't know what caused the exception
    - can't produce a proper error message / recover

### finally
- this clause runs whether or not an exception occured in the try-except block
- important when there is code that needs to be executed in all situations
- ```
    try:
        # code
    except[SOMETHING]:
        # handle error
    finally:
        # always executed
  ```
  
 ### Except and Finally together
 - Can put except and finally in one block
 - Common use is to just have finally clean up whether or not an error occurs

### Triggering Exceptions
- Your code can trigger exceptions using the 'raise' keyword
    - eg) ValueError can be raised whne you get a parameter that doesn't make sense:
        - ```
            def computeArea(radius):
                if radius < 0:
                    raise ValueError('radius should be non-negative')
          ```
          
### firstException.py
```
d = {'a': 1, 'b': 2, 'c' : 3, 'd' : 'four'}  # dictionary
userInput = input('Enter a letter: ')
try:
    x = d[userInput]  # accessing the position in dictionary given by user
    intVal = int(x)
    print(intVal)
    print('Done try block')
    y = 3/0

except KeyError:   # if user enters a letter that isn't in the dictionary
    print('The key "{}" is not found.'.format(userInput))
    
except ValueError as ve:  # value 'four' cannot be converted into an int
    print('The conversion of "{}" failed'.format(x))

except Exception as e:   # all other exeptions, print the exeption name
    print(str(e))


print('Afterwards')

```

### raiseException.py
```
import math

def computeArea(radius):
    if radius < 0:
        raise ValueError('radius must be positive')
    else:
        return math.pi * radius**2

x = 3
print(computeArea(x))

try:
    x = -3
    print(computeArea(x))
except ValueError:
    print('error')
```
 - output: 
    - 28.274333882308138 (for x = 3)
    - error ( for x = -3)


# CS1026 - Lecture 10

## Objects

### How we program
- Break a large task into smaller tasks
- Write functions for each of the tasts
- Problems with this:
    - Hard to maintain as size grows
    - Harder when more people are involved in creating one code

### Objects
- Instead of thinking of a program as tasks, can think of the things that are involved in the jobs
- **object**: a collection of data and methods that work on that data
- **method**: a type of function - a block of code that accepts parameters, returns a result

### Example 1: Student Transcript
- A student transcript can be modelled as a object
- The **data**: what we store in a student transcript:
    - Classes and grades 
    - Student name
    - Student number

- The **methods** that act on student transcript data: what we do to that transcript
    - Add a new course with a grade
    - Calculate the GPA

- Can have several student transcripts in a program (different objects)
- ```
    class StudentTranscript:
        def __init__(self, firstname, lastname, id, maj):
            self.firstname = firstname
            self.id = id
            self.grades = dict()  # lookup for grades grades['CLASS'] = GRADE
            self.major = maj
            self.email = lastname.lower()+'@uwo.ca'
                
        def addGrade(self, classID, grade):
            # is the grade okay
            # is this an update or a new grade
                
            if (grade < 0 or grade > 100):
                raise ValueError('Invalid Grade")
            else:
      ```
### Example 2: Robot
- Objects often model real world things
- A robot could be modelled by an object
- What are the data and methods?
    - Sense the environment
    - Detect obstacles
- **Data**: what is the state of the robot?
    - does the robot currently sense a wall
    - does the robot currently sense a cliff
    - is the robot currently docked?
- **Methods**: 
    - drive with given speed and angle
    - seek dock
    - clean
    - show LED display
    - play song

### Objects vs. Classes
- An object is one item (instance) in your program
    - you can have multiple objects of the same type in your program
- A class is the specification for a collection of objects
- Eg) 
    - StudentTranscript would be the class
    - Create multiple objects to store the transcripts of multiple students
- The class is the type of the variable (student record, robot)
- The objects are what is stored in the variables of that type

### We've already seen objects and classes
- strings, files, and lists are classes
- each time a list is created, a list object is created
- list objects have data and methods
- can have several list objects in code with different data
- the **data** in list: what is stored in the list
- the **methods**: what we do to the data:
    - append(), insert(), pop() are all methods that act on list objects
    - some take parameters, some don't
    - some return values, some don't

### Calling methods
- methods in the list class are called on an object
- some take parameters, some return results
- most use the dot notation
    - x = list()
    - x.append(30)
    - x.append(5)
    - x.sort()

### Interface of a Class
- The public interface of a class is:
    - all methods in the class
    - a description of how the methods work

### Creating objects
- lists - use the list() command, define a starting value
- We need to define how we let programs create objects
    - `x = list()`
    - `y = int('31')`

### Creating and Naming Classes
- Use the 'class' keyword to define a class
- Typicaly use a capital letter 
- To use:
    - Create a file with your class (eg., MyClass in file myclass.py)
    - In the fule using class:
        - from myclass import MyClass

### Defining methods of a class
- methods are functions within the body of a class (indeneted)
- methods can have parameters, return types like functions
- special parameter:
    - each method has a parameter listed first called 'self'
    - all other parameters go after 'self'
- methods work on instance variables (usually)

### Defining the data in a class
- Data in an object is called an instance variable or field
- each instance has its own version of the instance variables
- to create an instance variable, define a variable inside the object
    - use the prefix "self." to indicate that it's an instance variable
    - "Inside" means "in the body of the method"

### Inside a Method
- a method is like a regular function
    - it has parameters
    - can create local variables that exist for the life of the method call
    - except: it works on instance variables
        - instance variables are created and live for the life of the object
        - all method calls use the same instance variables

### Defining a Class
- Let's define class for a circle
- It will have (data)
    - center
    - radius
    - colour
- Operations:
    - Area of this circle
    - Is a point in the circle?

### Creating objects - constructor method
- Classes have a special method called the constructor that is called automatically when an object is created
- Never call the constructor yourself- it is called automatically
- **this is where you define your instance variables**
- the constructor can have arguments, but first should be self
- in python: `__init__(self)`
- only need one constructor per class, but you can have different types of behaviour for different situations with one
- use **default argument values** to specify the value of an argument when it's not given by the user
    - ```
        def __init__(self, arg1 = -1):
            self.__instanceVar = arg1
    - ```
   
### Other Methods
- Other methods in a class are defined like functionsn inside the body
- Use 'def' keyword and 'self'
- Can access any instance variables in the object
    - the instance variables are part of the state of the object
    - they are shared between all methods

### Accessors and Mutators
- Two common types of methods:
    - Accessors ('getters'):
        - methods that allow access to an instance variable of the object
    - Mutators ('setters'):
        - methods that set or update the value of an instance variable of the object
- Both are important because of **encapsulation**:
    - **code that uses your class should access the instance variables through methods**

### Creating and Using Classes
- Use the name of the class to create a new instance of the class
    - Constructor is called automatically
- Then: call methods on the object
    - Use the dot notation
        - `variable.method(...)`
    Specify all the parameters except 'self'
    
### Privacy in Classes
- Privacy: 
    - code that uses an object should use methods to modify data
    - instance variables should not be accessed or modified directly
- Encapsulation:
    - providing a public interface to the class
    - hiding other details about the implementation

- Why do we care about privacy?
- If you write and maintain a class over time, things will change
- Public interface should stay the same
- Implementation details may change
- Encapsulation helps with maintenance

### Privacy in Python
- underscores at the start of an instance variable indicate that it is private:
    - single underscore: others know not to use this instance variable directly
    - double underscore: private, can't (easily) be accessed outside this class
- Same rules for methods

### Private Methods
- Private methods support the methods in the public interface
- helps break big tasks into smaller tasks
- to call a method in side the class (private or note):
    - `self.othermethod(...)`

### References
- lists are objects - all objects use the references
- when dealing with an object, the variable contains a reference (or pointer)
- the reference is the address in memory for the data of the object
- in particular:
    - if you use a = b, where a, b are objects, then this is an alias
    - changes to objects in a function/method will cause permanent changes
        - `def func(obj1)  # modify obj1`

### == vs is
- when comparing lists/strings, == means "content is the same"
- if you want to check if two objects **point** to the same object, use 'is'
    - obj1 is obj2 is True when obj1 and obj2 point to the same object

### == in classes
- if nothing is done, == and 'is' perform the same job
- to implement own behaviour for ==, use __eq__ method
    - ```
        def __eq__(self,oth):
            # code for comparing self
            # and oth
      ```
    - can access the private variables of oth

### other methods
- __add__
- __sub__
- __pow__
- __repr__ - how to convert your object into a readable string
- __eq__ 
- __lt__ - less tha
- __le__ - less than equal to

### None
- means: this variable doesn't point to anything
- to test if a variable is None: `x is None`
    - Calling a method on a variable set to None is a RunTimeError

### Class Variables
- Instance variables are variables that live in an instance of an object
- can create variables that are at the class level
- one instance per class - all instances share the same variable

- Defining:
    - class variables are defined outside of an individual method
    - they are defined at the same level as methods

### Garbage Collection
- when an object (in memory) is not used anymore, the memory is reclaimed and can be used again
- refered to as garbage collection
- object is not used anymore when no more references point to that memory

### firstClass.py
```
import random

class FirstClass:
    # code for a class
    
    def sayHi(self):
        print('hi')
        
    def generateNumber(self):
        return random.randint(1,10)

    def makeInstance(self):
        self.instanceVar = 3  # defines an instance variable

    def useInstance(self):
        print(self.instanceVar)
```

### useFirstClass.py
```
from firstClass import FirstClass

newObj = FirstClass()
#print(newObj)

newObj.sayHi()  # calling the sayHi method in the FirstClass class.

z = newObj.generateNumber()
print(z)

print('-'*50)

# show how instance variables work
#newObj.makeInstance()
newObj.useInstance()

```

### BankAccount.py
```
class BankAccount:
    def __init__(self,name,id):
        self.customername = name
        self.accountID = id
        self.balance = 0

    def __eq__(self, other):
        return self.accountID == other.accountID


    def deposit(self, amt):
        if amt >= 0:
            self.balance += amt


    def withdraw(self, amt):
        if self.balance >= amt:
            self.balance -= amt
        else:
            raise ValueError("insufficient funds.")

    def printAccount(self):
        print('Account #{}: {}'.format(self.accountID,self.customername))
        print('Balance: {}'.format(self.balance))
```

### useBankAccount.py
```
from BankAccount import BankAccount

def main():

    acct1 = BankAccount("mike", 1)
    acct2 = BankAccount("mike", 2)
    acct3 = acct1

    acct2.deposit(100)
    acct3.deposit(100)

    acct1.printAccount()
    acct2.printAccount()

    print( acct1 is acct2)
    print( id(acct1))
    print( id(acct2))
    print( id(acct3))
    print( acct1 is acct3)

    print( acct1 == acct2)


main()
```

# CS1026 - Lecture 11

## Inheritance

### Creating lots of Objects
- Can use objects like we have seen already:
    - Define object in terms of data and methods
    - Create code
- Code reuse:
    - when we create many classes, we can see how we might need to reuse code from one class in another class
    - To do this use hierarchies

### Hierarchies
- Define a **first** class that has some behaviour (data and methods)
- Define a **second** class that can use the behaviour of the first balss
    - the behaviour in the second class is **inherited** from the first class
    - the two classes are in a **hierarchy**
    - **the first class is the parent of the second class**
- Relationship between parent classes and potentially several child classes forms a tree structure

### Parent Class and Child Class
- Class that defines the initial behaviour is called the parent class (superclass)
- Class that inherits the behaviour is called the child class (subclass)
- Most of the time: child class will add more behaviour

### Intuitive Example 1
- A 2D video game:
- Parent Class: generic item in the game
    - has an (x,y) position
    - has a velocity
- Child Class: player object
    - accepts inputs to change velocity
    - appearance data (size, colour)

### Intuitive Example 2
- Parent Class: Employee
    - name, salary, job title
    - methods associated with employee tasks
- Child Class: Supervisor
    - all of the above attributes and behaviours
    - supervises other employees
    - instance varaible: list of employees they supervise

### Defining Inheritance
- To inherit from a class, name it when defining the new class:
    - `class ChildClass(ParentClass)   # body of the child class   # add new methods`

### What does the child class get
- child class inherits all methods of the parent
- when the user creates a new object x of the child, they can call the methods in the parent class on that new object x
- they can also call any methods that you define in child class

### child class constructor
- should define its own constructor
- this is where new instance variables are defined
- but you probably want to create the instance variables from the parent class as well

- To create parent class instance fields in the child object, call the superclass constructor
    - `super().__init__()`
- **You defined your instance variables in the constructor right?**
- This line should be the first thing you do in the child class constructor
- super() refers to superclass
- special case: if child class has no constructor, parent constructor is called automatically

### Adding more specific behavior
- child class can specify additional methods that don't exist in the parent
- they can also overide methods in the parent class
    - change the behaviour of methods in the parent class by providing an implementation of the method in the child
- when we call the method in a child, it will call the overridden version

### Using super() in other methods
- can call parent version of the method in any child class method using the super()
- send parameters that the parent class is expecting for its method
- process helps reuse code - let the parent method do jobs that it can do
- Important for privacy
- variables that are private to parent aren't available to the child
     - lets the parent class define methods
     - lets the child class use those methods

### Principle of Substitution
- Inheritance makes sense when there is a "is-a" relationship between the parent and child
    - A square is a shape
- means we can substitute the parent class with a child class and code will still execute

### firstInheritance.py
```
import random

class ParentClass:
    def __init__(self):
        #print('starting parent constructor')
        self.var = 0

    def modifyVar(self):
        self.var = random.randint(0,100)

    def printVar(self):
        print('in ParentClass -> printVar')
        print(self.var)


class ChildClass (ParentClass):

    def __init__(self):
        #print('starting child constructor')
        super().__init__()  # calls parent class constructor.
        self.newInstance = -1

    def modifyVar(self):
        super().modifyVar()
        self.newInstance = random.randint(100,200)

    def newBehaviour(self):
        print('hi')
        print(self.newInstance)
        print(self.var)


v = ParentClass()
v.modifyVar()
v.printVar()
# v.printVar()
# # v.newBehaviour() - this doesn't work!

#print('before c= ChildClass()')
c = ChildClass()
c.modifyVar()
# c.printVar()
c.newBehaviour()
```
   
### noParnet.py
```
class NoParent:
    def __repr__(self):
        info = super().__repr__()
        print('I got {}'.format(info))
        return info

nn = NoParent()
print(nn)
```
 
