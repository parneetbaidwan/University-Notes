# CS1026 - Lecture 1

## Intro to Programming

### Calculating
Operators:
- +, -, *, /, exponents and parentheses
- Variables are used to save values
- Mathematical operators can be used for variables and numbers (literals)

### Variables
Variables hold values and update over time
Rules for naming:
- Letters, numbers and underscores
- Cannot start with a number
- Use informative names

### Division
- Two types of Division: Division and Integer Division
- Division: Divide normally
    - eg) 12/5 = 2.4
- Integer Division: Decimal part is removed
    - eg) 12//5 = 2
- Related operation: mod (%): Gives you only the remainder numerical
    - eg) 12%5 = 2 --> (5+5+2 = 12)

### Statements and Expressions
- Expression: any combination of literals, variables, and operations
- Statement: a line of code that can be executed
- Assignment Statement: "Variable = Expression"
    - "assign the variable the value of the expression"
    - **Only a variable** on the left hand side
    - Equal sign is the assignment operator

### Saving Code
- Save as a .py file
- Executes all at once

### Algorithms
- Once we start saving code, we are implementing algorithms
- Algorithm: A sequence of steps that accomplish a specific task
    - Finite set of steps, depends on data that we get
    - Always solves the problem
- They aren't specific to a language like Python
- When solving problems, algorthms are written before the code is written

### Operations
- Function calls: trig functions, square root, floor, ceiling, logs
- Math module:
    - Import math
    - To use a function, give name and the information needed
    - Store the result in a variable or use an expression
- Math Operators:
    - math.sin, math.tan, math.cos, math.asin...(radians)
    - math.degrees, math.radians (to convert)
    - math.sqrt
    - math.exp, math.log, math.log10
    - math.pi
- Non-math Operators
    - abs() - calculate the absolute value of a numerical value
    - round() - round a numerical value (to a certain number of decimal points)
- String Operations
    - '+' - concatenation (adding strings together)
    - '*' repition
    - len(x) - gives length of string

### Strings
- Store zero or more characters
- Can be assigned to variables and used in expressions
- Define using single or double quotes(' ', " ")
    - eg) myStr = 'COMPSCI 1026B'

### Types
- Strings and numeric values (ints, floats) are different types
- One variable can hold different types over its lifetime
- Some operations only work for some types

### Extracting information from strings
- Can extract a character from a string
- Use square brackets after the string name and provide position
- Position begins at zero, not one

### String Tools
- myStr.upper() - uppercase version of myStr
- myStr.lower() - lowercase version of myStr
- myStr.replace(oldText, newText) -  create a new version with the replacements

### Special Characters
- \n - newline character
- \t - tab character
- \'' or \' - quote characters
- \\ - backslash character

### User Input
- input()
    - Function returns the input the user types
    - Can specify a prompt (string) as a parameter to the function
    - Typically, store user input in a variable
        - use float() to convert to float
        - use int() to convert to integer
        
### Formatting
- Basic method:
    - `print('I want to show you', var1, 'and', var2)`
- Formatted:
    - `print('I want to show you {} and {}'.format(var1, var2))`
    - {} is where the variable will go
- Can also format decimals
    - {:.2f} will result in 2 decimal places
    - `print('A number: {:.2f}'.format(floatingVar))

### Comments
- Anything written after '#' is a comment
- Ignored within the actual code
- Can also use ''' ''' for long paragraphs of comments


### circleArea.py
this program computes the area of a circle from its radius
```
userInp = input('Please type in the circle radius: ')
radius = float(userInp)
area = 3.141 * (radius**2) # area formula
print('The area of a circle with the radius {} is {:.2f).'.format(radius,area))
```
- output assuming radius is 2: 12.56

### firstCode.py
```
radius = 5
area = 3.141 * (radius**2)
print(area)
print(radius)

radius = 10
area = 3.141 * (radius**2)
print(area)
```
- output: 
    - 78.525
    - 5
    - 314.1
    
### firstInput.py
```
userInp = input('Type in your first name: ')
greeting = 'Hi' + userInp
print(greeting)
```
- output: Hi Parneet

### mathOps.py
```
import math
a = 1
b = 6
c = 3

x = (-b + math.sqrt(b**2 - 4*a*c)) / 2*a
print(x)
```
- output: -0.5505102572168221

### string.py
``` 
myString = 'this is some text'
secondString = 'more text'
print(myString + secondString)

newString = myString * 3
print(newString)

print(len(myString))
firstCharacter = myString[0]
print(firstCharacter)
```
- output:
    - this is some textmore text
    - this is some textthis is some textthis is some text
    - 17
    - t


# CS1026 - Lecture 2

## Conditions

### Conditions
- Conditions are a way to represent whether something is true or false
  - 3 > 5 
  - x >= 5

### Relational Operators
- Operators are needed to express conditions
- Comparisons between two values:
  - >, >=, <, <=
- Equality and non equality:
  - ==, !=

### If Statements
```
if(condition):
  #statement1
  #statement2
```
- Statements will only execute if the condition is true
- White space is very important --> Lines must be indented

### If with Else
```
if(condition):
  # executed if condition is TRUE
else:
  # executed if condition is FAlSE
```

### If, Elif, Else
```
if(condition1):
  # executes if condition1 is true
elif(condition2):
  # executes if condition2 is true
else:
  # executes if neither condition is true
```

### Boolean Operators
- and: true if both conditions are true
  - eg) x >= 0 and x <= 10
- or: true if one or both conditions are true
  - eg) grade < 0 or grade > 100
- not: "flip" the true - true if condition is false and vice versa
  - eg) not(x > 0)
  
- Short Circuit Evaluations
  - Evaluate the left operand and only evaluate the right if needed
    - or: if the left is true, expression is true
    - and: if left is false, expression is false
    
### Comparisons
- Comparing Floating Point Numbers
  - avoid using equality with floating point numbers:
    - 67.76 * 100
  - use epsilon - a small floating point tolerance that represents "close enough"
    - test |x - y| < epsilon for some small value of epsilon
      ```
      epsilon = 1e - 14
      if(abs(x-y) < epsilon):
      ```
- Comparing Strings
  - compare with == and !=
    - every single character in both strings are the same:
      - same length
      - each position is the same character
      
  - compare with < 
    - operator is true for two strings if they are in lexicographic order
      - "alphabetical order", "phone book order"
    - easy if two strings differ in some position
    - if one string is a prefix of the other, it comes first:
      - eg) David < Davidson
    - Numbers --> Uppercase --> Lowercase

### Boolean Values
- True and False
  - Store values in a variable:
    - `boolVar = True`
  - Can be the result of a comparison:
    - `boolVar = (1 > 3)`
  - Can use in if statements
    - ```
      boolVar = (1 > 3)
      if boolVar:
        print('...')
       ```
### Try-Except
- A condition Statement but without explicit conditions
- Used primarily for error handling
- ```
  userInput = input('Enter an integer: ')
  try:
    integerValue = int(userInput)
  except ValueError:
    print('Error, etc...')
  ```

### boolOps.py
```
grade = 50
if grade < 0 or grade > 100:
  print('grade is invalid')
else:
  print('grade is valid')
```

### elifExample.py
```
x = 10
y = 5
z = 30

if x == y:
  print('x and y are the same')
elif x > z:
  print('x is greater than z')
elif y > z:
  print('y is greater than z')
else:
  print('nothing above was true')

print('goodbye :)')
```

### firstIf.py
```
# short program showing how to use an if statement

# get user input
userInp = input('Enter your revenue: ')
revenue = float(userInp)

userInp = input('Enter your expenses: ')
expenses = float(userInp)

# your net
net = revenue - expenses

if net >= 0:
  print('You made a profit of ${}'.format(net))
  print('Good job!')
else:
  print('You lost ${}'.format(net))
  print('Better luck next time.')
print('Goodbye.')
```

# CS1026 - Lecture 3

## Iteration

### While Loops
- While Loop: Test a condition and execute the code if the condition is true, repeat
```
while(condition):
    #body
```

### Example Loop
```
counter = 0  # before loop
while(counter < 5):
    print('count is {}'.format(counter))
    counter = counter + 1
print('done loop')  # after loop
```

### While Loop Test
- While loop condition is tested:
    - when the loop is first encountered
    - after each execution of the body of the loop
- When designing your loop, make sure it captures what you want each time

### Infinite Loops
```
counter = 0
while (counter < 10):
    print('counter is {}'.format(counter))
```

- Missing an incrementation

### Other While Loop Pitfalls
- Floating point loops:
    - avoid use of floats, instead use integers
- Continue to update everytime

### Input Processing Loops
1. Verifying that a user inputs a correct value
2. Allowing multiple input

### Verifying Input
- Prompt the user for input
- While test should be - "while input is **no good**
- Inside loop: kindly remind user with prompt

### Allowing Multiple Loop
```
num = int(input('Enter a number(-1 to quit): ')
while(num != -1):
    # process num
    # prompt again
```
- Sentinel Value:
    - Special value that signals the end of input
    - Sentinel should not be a valid input value
 
### Flag Variables
- Can use a variable that stores a Boolean value as a **flag variable**
- The variable flags that the loop should end
- Useful for complex loops
```
boolVar = True
boolVar = (x > 0)
```

```
done = False  # done is the flag var
while (not done):
    # processing
    if (condition):
        done = True
    else:
        # more processing
```

### For Loop
- For loops are another form of a loop that work a predefined number of times
```
for i in range(5):
    print('the value of i is {}'.format(i))
```

### for loop or while loop
- for loop: 
    - if you know how many times the loop will execute
- while loop: 
    - if the condition relies on unknown information
    - if you can express a Boolean condition
 
### range()
- range(a,b,c)
    - a: starting value
    - b: end before this value (at b-1)
    - c: skip by this value
- examples:
    - range(4,20) --> 4, 5, 6, 7,...17, 18, 19
    - range(-5,10,3) --> -5, -2, 1, 4, 7

### For Loop over Strings
- Can use a for loop with range() for strings, but can also work with characters
```
for char in myStr:
    print(char)
```

### Nested Loops
- When loops are within loops: **Inner loop executes first**

```
for i in range(5):
    for j in range(4):
        print("{},{}".format(i,j))
```

output: 
- 0,0
- 0,1
- ...
- 1,0

### circleArea2.py
```
# this program computes the area of the circle from its radius

userInp = input('Please type in the circle radius (positive): ')
radius = float(userInp)

while radius < 0:
    # know that the input is bad
    userInp = input('Your input of {} was negative. Please enter a positive: '.format(radius))
    radius = float(userInp)

area = 3.141 * (radius**2)
print('The area of a circle with the radius {} is {:.2f}.'.format(radius,area))
```

output:
- input: -3
    - "Your input of -3 was negative. Please enter a positive: "
- input: 1
    - 3.141
    
### firstWhile.py
```
counter = 1

print('Before while loop')

while (counter <= 5):
    print('Counter is {}'.format(counter))
    counter += 1
    
print('After while loop')
```
output:
- Before while loop
- Counter is 1
- Counter is 2
- Counter is 3
- Counter is 4
- Counter is 5
- After while loop

### forLoops.py
```
# simple range statement
for i in range(10):
    print('The value of i is {}.'.format(i))
    if i <= 3:
        print('small')
    else:
        print('large')
        
# even numbers here
for i in range(2,10,2):
    print('The value of i is {}.'.format(i))
    if i <= 3:
        print('small')
    else:
        print('large')

myStr = 'abcdef'

for char in myStr:
    print(char)    
```

output:
    - The value of i is 0.
    - small
    - The value of i is 1.
    - small
    - ...
    - The value of i is 9.
    - large

    - The value of i is 2.
    - small
    - The value of i is 8.
    - large

    - a
    - b
    - f
    
### nested.py
```
for i in range(5):
    print('starting i loop')
    for j in range(4):
        print('{},{}'.format(i,j))

print('done')
```

- output:
    - starting i loop
    - 0,0
    - ...
    - 0,3
    - starting i loop
    - 1,0
    - ...
    - 1,3
    - starting i loop
    - 2,0
    - ...
    - 2,3
    - starting i loop
    - 3,0
    - ...
    - 3,3
    - starting i loop
    - 4,0
    - ...
    - 4,3
    - done
    

# CS1026 - Lecture 4

## Randomness and Simulation

### Random Numbers
- Useful for:
    - Games: introduce an element of randomness for user
    - Simulations: many complex problems can be solves approximately using randomness

### Generating Random Numbers
- Use random library
- random() function:
    - generates a number between 0 and 1: (0 <= r <= 1)
    - need to import
```
from random import random  # 1st - module; 2nd - function
r = random()
```

### "Random"
- The numbers aren't actually random: **pseudorandom**
- They are generated deterministically: repeat pattern length 2^19937 - 1
- Python documentation: "not suitable for cyrptographic purposes

### Pseudorandom and Seed
- Pseudorandom starts with a seed
- If the random generator gets the same seed, it generates the same results
- By default, the seed is based on the current time
- Setting the same seed value can be helpful to help debug your code: `random.seed(10)`

### Random Integers
```
from random import randint
r = randint(a,b)
```
Generates a random number between and including a and b

### Dice.py
```
from random import randint  # importing a random integer

count12 = 0  # how many times is 12 seen
count7 = 0  # how many times is 7 seen

for i in range(1000):  # 1000 dice rolls
    dice1 = randint(1,6)
    dice2 = randint(1,6)
    
    sumDice = dice1 + dice2
    
    if (sumDice == 12):
        count12 += 1
    elif (sumDice == 7):
        count7 += 1
        
print('We got {} 12s and {} 7s'.format(count12, count7))
```

Example Output: We got 32 12s and 171 7s


# CS1026 - Lecture 5

## Data Structures

### Variables
- Variables store a single value
    - Different types
    - Only one value at a time
- Data Structure: A way to store multiple values in a uniform way

### List
- A list stores multiple values at once
- Lists are:
    - Heterogenous: Can store different types at the same time
    - Dynamic: The number of values in a list can change over time
    - Ordered: We can access elements form the list by asking for the position data

- Lists are defined using square brackets and a name:
    - `mylist = [2, -1, 5]

- To access one value, use square brackets after the variable name:
    - `mylist[0]`
    - this would result in: 2

### Indexing
- Indexing: accessing a value using []
    - Used to read or write a list value

- len() for length of list
- Index: the value inside the brackets; position you are accessing
    - always starts at 0

- Indexing out of list length will give an error
- Last element:
    - `mylist[len(mylist) - 1]`
    - `mylist[-1]`

### Creating Lists
- List with elements:
    - define variable and add elements with square brackets
    - `myList = [e1, e2, e3]

- List with no elements:
    - define variable and add square brackets with nothing between them
    - `myList = []`

- Another way:
    - `myList = list()`

### Slicing
- Slicing: extract regions of a list 
    
- `myList[a:b]`
    - Starts at a; ends at value before b (b-1)
    - If a or b is omitted, python will use the start or end of the list respectively
    - Result: new list
        - However, when you index with a single integer, you will get an integer

- `myList[a:b:c]`
    - Starts at a; ends at value before b; skips by value of c
    - Any number can be negative

### List Operations
- Concatenation: adding two lists using '+'
- Repetition: repeat a list using '*'
    - `myList = [0] * 10`

- list1.append(x): add element x to the end of list1
- list1.extend(list2): add all of list2 to the end of list1
    - .extend() modifies the list and creates a new list
    
- list1.insert(k,x): insert element x at the spot k in list1
    - everything at spot k and up is shifted up by one
    - if k is bigger than the length, the element is added at the end

- list.pop(k): remove element at the spot k in list1
    - everything at spot k and beyond is shifted down
    - everything that is removed is returned by the call
    - if k is bigger than the length, error
    - if k is not provided, remove the last element

- list.remove(x): remove the first occurence of element x from list1
    - smallest index
    - everything past the deleted is shifted down one spot
    - if the element isn't in the list, an error will occur
    - Pop vs. Remove:
        - removing an element, not a position

### List Tests
- in
    - tests whether an element is in the list:
        - `if x in list1:`

- not in
    - tests whether an element is not in the list:
        - `if x not in list1`

- index()
    - finds the index of an element
        - returns an error if the element isn't in the list

    - `list.index(x)`

### Equality
- Use == and != 
- Tests whether each element at every position is equal

### References (Pointers)
- List variables use references
- The reference is the address (in memory) of where the list data is stored
- The list variable contains the reference

### List Assignment
- What happens when -> `list1 = list2`
    - Copying the refernce in list2 into the list1 variable
    - NOT COPYING THE DATA
    - Effect:
        - list1 is now an alias for list2
        - changes to list 1 affect list2 and vice versa

- To get a separate copy:
    - Use slicing:
        - `list1 = list2[:]

    - Use list keyword:
        - `list1 = list(list2)

### Numerical List Operations
- sum(L): add all the elements of a list
- max(L): find the biggest element
- min(L): find the smallest element
- sorted(L): return a sorted version of the list
- L.sort(L): sort the list "in place" --> no new list

### String List Operations
- Can use max, min, sorted, and sort
- Instead of sum, use join
    - x.join(list)
        - x is element that is glued between the list elements
        - `' '.join(list)` --> Common

### Tuples
- Similar to lists but immutable; cannot change the content
- Use round brackets to define
    - `myTuple = (1, 3, 5, 7, 8)
- Can also be indexed
    - `myTuple[1]`

### Tuple Operations
- len, in, ==

### Simultaneous Assignment
- Suppose x and y are already variables
- Use tuples to swap values
    - `(x,y) = (y,x)`
- Can be done for any number of variables

### Strings as Data Structures
- Strings are immutable
    - No aliasing problem
    - No writing to individual characters using []

### For Loops and Data Structures
- For loops can be used to iterate over data structures
```
myList = [1, 2, 3]
for x in myList:
    print(x)

output:
1
2
3
```

### For loops with range
- Range can also be used with data structures:
```
for posn in range(len(myList)):
    # use posn as an index in the list
    # eg. myList[posn]
    print(myList[posn])
```

### Multi-dimensional Lists
- Can have multi-dimensional lists
- `table = [[1,2,3], [4,5,6], [7,8,9]]`
- Can be indexed:
    -`table[0][1]` is equal to 2 (first list, second item)
    
- Accessing:
    - Using in:
        ```
        for row in table:
            for elem in row:
                # can access element
        ```
    - Using ranges:
        ```
        for i in range(len(table)):  # number of rows
            for j in range(len(table[i])):  # number of columns
                # can access table[i][j]
        ```
                
     - For bigger sizes:
        - Use '*' to create bigger arrays
        ```
        table = []
        for i in range(numRows):
            table.append([0] * numCols)
        ```

### Ragged Multidimensional Arrays
- Lengths of each row could differ (different number of columns)
- Both of the loop formats would still work
`ragged = [[1], [2,3], [4,5,6], [7]]`
       

### firstList.py
```
TWO = 1
myList = ['mike', 2, 3.141, 99]  # defining a list of length 4

print('First element in the list is {}'.format(myList[0]))

myList[TWO] = 9000.1  # updates a position in the list

print(myList)
print(len(myList))
```
- output: 
    - First element in the list is mike
    - mike, 9000.1, 3.141, 99
    - 4
### list2d.py
```
myTable = [ [1,2,3,4], [5,6,7,8], [9,10,11,12]]
# 1  2  3  4
# 5  6  7  8
# 9 10 11 12

# print(myTable[1][3])

for i in range(len(myTable)):  # i = 0, 1, 2
    print(myTable[i]) # print whole row
    for j in range(len(myTable[i])):  # j = 0, 1, 2, 3
        print(myTable[i][j])
        print('--')
    print('done row {}'.format(i))
```

- output:
    - ```
     [1,2,3,4]
     1
     --
     2
     --
     3
     --
     4
     done row 0
     ...
    
    - ```
### listAsst.py
```
list1 = ['alpha', 'beta', 'gamma', 'delta', 'epsilon']
list2 = list1

print('list2 is {}'.format(list2))

list2.append('omega')  # changing list 2

print('list1 is {}'.format(list1))  # change is seen in list 1 also
```
- output:
    - ```
    list 2 is ['alpha', 'beta', 'gamma', 'delta', 'epsilon']
    list 1 is ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'omega']
    ```

### listTests.py
```
# create a list
list1 = ['alpha', 'beta', 'gamma', 'delta', 'epsilon']

# use 'in' test

if 'omega' in list1:
    print('yes')
    posn = list1.index('omega')  # if it exists, this is the position
else:
    print('no')

list2 = ['beta', 'alpha', 'gamma', 'delta', 'epsilon']

# print(list1 == list2) --> False
list3 = list2
```
- output: no

# CS1026 - Lecture 6 

## Functions

### Organizing Code
- You can write code that becomes more and more complex but that creates problems
- Problems of **maintainability**:
    - Code becomes harder to read, write, modify, and debug
    - Hence, need to improve organization of the code

- Maintainance:
    - involves reading existing code
    - if the code is not readable and organized, it is going to be hard to maintain

### Functions
- Isolate **blocks of code** that form a self-contained task
- These tasks will be put in a **function**:
    - math functions: sin(), round(), sqrt()
    - abs()
    - print()
    - len()
- Functions:
    - can be called to produce effects or results
    - take information needed to do the job
        - len() takes a list, tuple, string
        - random() doesn't take any information

    - can return a piece of information
        - len() returns the length of the string or list
        - print() doesn't return anything

### Writing Functions
- Required information:
    - function name
    - information required to accomplish a task
    - provide code to do that task
    - return if applicable

### Simple Python Function
- ```
    def myFunction():
        # code
- ```
- First line is called the header - gives name, and other information
- Code is called the body
- Indentation, colon

### Writing a Function
- ```
    def myFunction(param1, param2):
        # body
        # typically use param1, param2
        
        return returnVariable
- ```

- **Parameters**:
    - Define the parameters in the header but do not assign them a value
    - Modifying Parameters:
        - What happens depends on the type of parameter
        - If that parameter is immutable (string, int, tuple...):
            - changes inside the function don't matter
            - changes do not affect the value when the function is done
        - If the parameter is mutable:
            - changes to a list in a function will create a permanent change

- **Body**:
    - **local variables**: variables defined in the body of the function
        - can't be accessed outside the function
        - created when function starts and destroyed when the function ends
        - could have two different local variables with same name in different functions

    - **global variable**: variables defined in a method and exist for the life of the method
        - defined outside a function that is visible inside a function defined
        - need to tell a function you want to access a global variable within the body
            - `global myVar` --> don't do this
            - instead: structure your code so info is passed by parameters 

- **Return**:
    - Last executed statement in the function
    - No code after the return statement
    - Try to only have one return statement per function
    - Can return a variable, value, expression, or a tuple

- main()
    - write this after your function
    - it should contain all the executable code in your program that's not in a function

### Calling a Function
- If you've written a function called myFunction, you can call it in your code:
    - `myFunction()`
- After defining your function, can call it by:
    - supplying the parameters (if any_
    - saving the result (if any)
    - ` myVar = myFunction(otherVar1, otherVar2)`

### Documenting Functions
- Use triple quotes (docstring) after the header to start a comment describing the function
- ```
    def iCry(Parneet):
        ''' this function cries a lot'''
        # body
- ```
- Include:
    - what the function does
    - what it returns
    - what the parameters are

### firstFunction.py
```
def myFunction():
    print('Hello World')
    print('More printing')
    
def myFunction2(myParam):
    print('You sent in the value {}'.format(myParam))
    return 2*myParam

def addTwoNumbers(param1, param2):
    '''
        addTwoNumbers: function that takes two parameters and returns their sum
        Parameters: param1 - a number
                    param2 - a number
        Returns: the sum of param1 and param2
    '''
    
    total = param1 + param2
    return total

def main():
    print('before function')
    myFunction()
    
    print('after function')
    
    myVar = 200
    x = myFunction2(myVar)  # call the function and send it parameter valued at 200
    
    print('We got back {}'.format(x))
    

main()
```
- output:
    - ```
        before function
        Hello World
        More Printing
        after function
        You sent in the value 200
        We got back 400
    - ```
    
### modifyParam.py
```
def function1(param1):
    # param is an integer
    param1 = 5
    print('in function: {}'.format(param1))
    
def function2(param1):
    # param is a list
    param1[0] = -1
    print('in function: {}'.format(param1))
    
def main():
    var = 10
    function1(var)
    print('after function, in main: {}'.format(var))
    
    print('--'*50)
    myList = [1,2,3]
    function2(myList)
    print('after function, in main: {}'.format(myList))


main()
```
- output:
    - ```
        in function: 5
        after function, in main: 10
        ---------------------------------------------------------------------------------
        in function: [-1,2,3]
        after function, in main: [-1,2,3]
    - ```
